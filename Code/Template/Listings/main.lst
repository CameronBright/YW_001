C51 COMPILER V9.59.0.0   MAIN                                                              10/09/2024 16:28:16 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Worksoftware\Keil\ARM\C51\BIN\C51.EXE User\main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\User;.\Hardw
                    -are;.\Startup;.\Readme) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /*
   2          
   3          Version: 1.0.2
   4          Check out the Readme.txt for more details 
   5           
   6          */
   7           
   8          //系统库
   9          #include "main.h"
  10          #include <stdio.h>
  11          
  12          //外设库
  13          #include "gpio.h"
  14          #include "timer.h"
  15          #include "key.h"
  16          #include "seg.h"
  17          #include "uart.h"
  18          //#include "eeprom.h"
  19          #include "config.h"
  20          
  21          //-----------功能选择区-----------
  22          
  23          
  24          //程序执行函数
  25          void Key_Proc(void);       //Keystroke process function
  26          void Disp_Proc(void);      //LCD Dsiplay process function
  27          
  28          //自定义功能函数 
  29          void Delay(unsigned int delay); //定时器延时 会卡住当前函数，但不会影响整个代码
  30          void Peripheral_Init(void);//外设初始化函数
  31          
  32          //串口功能函数
  33          void init_Uart2();//串口2初始化
  34          void Uart2Send(char dat);
  35          void Uart2SendStr(char *puts);//发送数据
  36          
  37          //----------------可能需要修改的变量-------------------------------------
  38          
  39          //刷新计数,按键10ms扫描一次,数码管200ms刷新一次
  40          u16 key_slow_down = 0; //按键刷新计数
  41          u16 disp_slow_down = 0; //显示刷新计数
  42          
  43          /*按键相关变量*/
  44          u16 key_tick;        //long key press count
  45          bit key_sw = 1;
  46          bit keylong = 1;
  47          
  48          u8 key_value = 0;       //按键值
  49          u8 key_down;            //按键下降沿
  50          u8 key_up;              //上升沿
  51          u8 key_old;             //上次的按键值
  52          
  53          u16 delay_tick;         //软件延时计数
  54          
C51 COMPILER V9.59.0.0   MAIN                                                              10/09/2024 16:28:16 PAGE 2   

  55          /*数码管显示相关变量*/
  56          char seg_string[4];     //数码管显示字符串
  57          char seg_buf1[4];       //数码管1显示缓冲区
  58          char seg_buf2[4];       //数码管2显示缓冲区
  59          
  60          u8 LED_buf;           //按键下LED控制 0b0011 1111 1为亮 0为灭
  61          u8 pos = 0;             //数码管段选
  62          
  63          /*串口相关变量*/
  64          u8  TX2_Cnt;    //U2发送计数
  65          
  66          u8  RX2_Cnt;    //U2接收计数
  67          
  68          bit B_TX2_Busy; //U2发送忙标志
  69          
  70          u8  RX2_Buffer[16]; //u2接收缓冲
  71          
  72          /*外设相关变量*/
  73          u16 buzzer_tick;        //蜂鸣器短响计数
  74          
  75          /*代码控制变量*/
  76          u8 mode;                //模式切换
  77          
  78          void main(){
  79   1        //P_SW2 |= 0x80;  //扩展寄存器(XFR)访问使能
  80   1        GPIO_Init();      //引脚初始化
  81   1        Timer1_Init();    //定时器初始化
  82   1        
  83   1        init_Uart2();
  84   1        
  85   1        EA = 1;           //打开总中断
  86   1        Config_Init();    //初始化配置
  87   1        Peripheral_Init();//外设函数初始状态
  88   1        
  89   1        Uart2SendStr("STC8H TEST!");
  90   1        while(1)
  91   1        {
  92   2          
  93   2          
  94   2          Key_Proc();
  95   2          Disp_Proc();
  96   2          LED1 = 0;
  97   2          LED2 = 0;
  98   2          LED3 = 0;   
  99   2          Uart2SendStr("STC8H TEST!");
 100   2          
 101   2        }
 102   1      } 
 103          
 104          //================中断函数=======================
 105          void Timer1_Isr(void) interrupt 3   //1ms 中断一次
 106          {
 107   1        //本中断函数内全是赋值，没有运算，每次中断时间不会过长
 108   1        if(++key_slow_down == 10) key_slow_down = 0;   //10ms扫描一次按键
 109   1        if(++disp_slow_down == 200) disp_slow_down = 0;//200ms刷新一次数码管
 110   1         
 111   1      //--------------------1s定时器---------------------------
 112   1        
 113   1      
 114   1      //--------------------外设控制---------------------------
 115   1        
 116   1        //按键长短按计时
C51 COMPILER V9.59.0.0   MAIN                                                              10/09/2024 16:28:16 PAGE 3   

 117   1        if(key_tick > 0) key_tick--;  
 118   1          
 119   1        //软件延时
 120   1        if(delay_tick > 0) delay_tick--;//延时函数 使用会卡住当前函数，但不影响其他功能
 121   1          
 122   1        //数码管段选刷新
 123   1      
 124   1        Seg_Disp1(seg_buf1,pos);
 125   1        Seg_Disp2(seg_buf2,pos);
 126   1        if(++pos > 3) pos = 0;
 127   1      }
 128          
 129          //================按键逻辑函数=======================
 130          void Key_Proc(void)        //Keystroke process function
 131          {
 132   1        if(key_slow_down) return;   //10ms进入一次此函数
 133   1          key_slow_down = 1;
 134   1          
 135   1        key_value = Key_Scan(); //读取键值 强制消抖
 136   1        key_down = key_value & (key_value ^ key_old); //下降沿
 137   1        key_up = ~key_value & (key_value ^ key_old);  //上升沿
 138   1        key_old = key_value;
 139   1        
 140   1        if(key_down)       //长按3秒
 141   1          key_tick = 3000;
 142   1        
 143   1         //key_old键值 tick按下计数  long自锁，保证按键代码只触发一次
 144   1        if(key_old && key_tick == 0 && keylong){
 145   2          keylong = 0;    
 146   2          if(key_old == 1){     //长按童锁键    
 147   3            //------按键1长按功能--------
 148   3            
 149   3            //------按键1长按功能--------       
 150   3          }
 151   2          if(key_old == 4){ //长按磁化键  
 152   3            //------按键4长按功能--------
 153   3      
 154   3            //------按键4长按功能--------   
 155   3          }
 156   2        }
 157   1        
 158   1        if(key_up) //keydown-keyup顺序不能更改
 159   1          keylong = 1;
 160   1        
 161   1        if(key_tick && key_sw){
 162   2          switch(key_up)
 163   2          {
 164   3            case 1://按键1
 165   3            {     
 166   4              if(++mode > 3) mode = 0;
 167   4              break;
 168   4            }
 169   3            case 2://按键2
 170   3            {
 171   4              if(--mode == 0) mode = 0;
 172   4              break;
 173   4            }
 174   3            case 3://按键3
 175   3            {
 176   4              Buzzer ^= 1;
 177   4              break;
 178   4            }
C51 COMPILER V9.59.0.0   MAIN                                                              10/09/2024 16:28:16 PAGE 4   

 179   3            case 4://按键4
 180   3            {  
 181   4              mode++;
 182   4              break;                             
 183   4            }                                    
 184   3            default:                             
 185   3              break;
 186   3          }
 187   2        }
 188   1          
 189   1      }
 190          
 191          //================显示逻辑函数=======================
 192          void Disp_Proc(void)       //LCD Dsiplay process function
 193          {
 194   1        if(disp_slow_down) return;   //200ms进入一次此函数(200ms刷新一次屏幕)
 195   1          disp_slow_down = 1;
 196   1        
 197   1        sprintf(seg_string,"---%d",(unsigned int)mode); 
 198   1        Led_Trans(seg_string,seg_buf1); 
 199   1      
 200   1        sprintf(seg_string,"----");
 201   1        Led_Trans(seg_string,seg_buf2); 
 202   1        
 203   1      }
 204          
 205          //================自定义函数=======================
 206          
 207          //定时器延时 会卡住当前函数，但不会影响整个代码
 208          void Delay(unsigned int delay) 
 209          {
 210   1        delay_tick = delay;
 211   1        while(delay_tick > 0);
 212   1      }
 213          
 214          /*
 215          tick: 蜂鸣器响的时间ms
 216          */
 217          void Buzzer_Ctrl(u16 tick)  
 218          {
 219   1        buzzer_tick = tick;
 220   1      }
 221          
 222          void Peripheral_Init(void)//外设初始化函数
 223          {
 224   1        Buzzer_Ctrl(200);//上电短响200ms一次
 225   1        LED_buf = 0x30;
 226   1       
 227   1      }
 228          
 229          
 230          //================串口2功能函数=======================
 231          void init_Uart2()//波特率11.0592
 232          
 233          {
 234   1         S2CON=0x10;   //打开允许接收
 235   1         T2L = 0xE8;    //设置定时初始值
 236   1         T2H = 0xFF;    //设置定时初始值
 237   1         AUXR|=0x04;   //开启T2定时器1T工作模式
 238   1         AUXR|=0x10;   //开启T2定时器T2R=1
 239   1      
 240   1         IE2|=0x01;//开启ES=1
C51 COMPILER V9.59.0.0   MAIN                                                              10/09/2024 16:28:16 PAGE 5   

 241   1         P_SW2 &= 0xFE;//串口2p10p11
 242   1         B_TX2_Busy = 0;//忙检测
 243   1         TX2_Cnt = 0;//发送计数
 244   1         RX2_Cnt = 0;//接收计数
 245   1      }
 246          
 247          void Uart2Send(char dat)//u2发送单字符
 248          
 249          {
 250   1            while(B_TX2_Busy);
 251   1            B_TX2_Busy=1;
 252   1            S2BUF=dat;
 253   1      }
 254          
 255          void Delay1ms(unsigned char x)    //@12.000MHz
 256          
 257          {
 258   1         unsigned char i, j;
 259   1         i = 16;
 260   1         j = 147;
 261   1         while(x--)
 262   1         {
 263   2            do
 264   2            {
 265   3              while (--j);
 266   3            } while (--i);
 267   2         } 
 268   1      }
 269          
 270          void Uart2SendStr(char *puts)//U2发送字符串
 271          {
 272   1           while(*puts)
 273   1            {
 274   2              Uart2Send(*puts++);
 275   2            }
 276   1      
 277   1      } 
 278          
 279          void UART2_isr (void) interrupt 8//Uart2串口中断入口
 280          
 281          {
 282   1      
 283   1      
 284   1          if((S2CON & 1) != 0)
 285   1      
 286   1          {
 287   2      
 288   2              S2CON &= ~1;    //Clear Rx flag
 289   2      
 290   2              RX2_Buffer[RX2_Cnt++] = S2BUF;
 291   2      
 292   2              RX2_Cnt&=0x0f;
 293   2      
 294   2                SBUF=S2BUF;//发送至串口2
 295   2      
 296   2          }
 297   1      
 298   1          if((S2CON & 2) != 0)
 299   1      
 300   1          {
 301   2      
 302   2              S2CON &= ~2;    //Clear Tx flag
C51 COMPILER V9.59.0.0   MAIN                                                              10/09/2024 16:28:16 PAGE 6   

 303   2      
 304   2              B_TX2_Busy = 0;
 305   2      
 306   2          }
 307   1      
 308   1      }
 309          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    603    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     47       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
