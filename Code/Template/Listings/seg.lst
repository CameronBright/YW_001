C51 COMPILER V9.57.0.0   SEG                                                               09/28/2024 23:49:16 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE SEG
OBJECT MODULE PLACED IN .\Objects\seg.obj
COMPILER INVOKED BY: D:\Software\WorkSoftware\Keil5\C51\C51\BIN\C51.EXE Hardware\seg.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.
                    -\User;.\Hardware;.\Startup;.\Readme) DEBUG OBJECTEXTEND PRINT(.\Listings\seg.lst) TABS(2) OBJECT(.\Objects\seg.obj)

line level    source

   1          #include "seg.h"
   2          
   3          /* 
   4          ======================================================================================
   5          Function:
   6          此函数将*seg_string字符串中每一位的内容转换成数码管显示的段码
   7          例如：char seg_string[2] = {0,1}; //要显示0和1
   8                char seg_buf[2] = {0,0};    //缓冲区
   9                
  10                Led_Trans(seg_string,seg_buf);//转换
  11                
  12                //转换结果
  13                seg_string[2] = {0,1};
  14                seg_buf[2] = {0xFC,0x60};
  15                              0xFC数码管表示为0，0x60为1
  16          ======================================================================================  
  17          */
  18          //共阴数码管
  19          //void Led_Trans(unsigned char *seg_string,unsigned char *seg_buf)
  20          //{
  21          //  unsigned char i,j = 0;
  22          //  unsigned char temp;
  23          //  
  24          //  for (i=0;i<2;i++,j++)
  25          //  {
  26          //    switch(seg_string[j]){
  27          //      case '0': temp = 0xFC; break;
  28          //      case '1': temp = 0x60; break;
  29          //      case '2': temp = 0xDA; break;
  30          //      case '3': temp = 0xF2; break;
  31          //      case '4': temp = 0x66; break;
  32          //      case '5': temp = 0xB6; break;
  33          //      case '6': temp = 0xBE; break;
  34          //      case '7': temp = 0xE0; break;
  35          //      case '8': temp = 0xFF; break;
  36          //      case '9': temp = 0xF6; break;
  37          //      default:  temp = 0xFC; break;
  38          //    }
  39          //    seg_buf[i] = temp;
  40          //  }
  41          //  
  42          //}
  43          
  44          //共阳数码管
  45          void Led_Trans(unsigned char *seg_string,unsigned char *seg_buf)
  46          {
  47   1        unsigned char i,j = 0;
  48   1        unsigned char temp;
  49   1        
  50   1        for (i=0;i<2;i++,j++)
  51   1        {
  52   2          switch(seg_string[j]){
  53   3            case '0': temp = 0xFC; break;
  54   3            case '1': temp = 0x60; break;
C51 COMPILER V9.57.0.0   SEG                                                               09/28/2024 23:49:16 PAGE 2   

  55   3            case '2': temp = 0xDA; break;
  56   3            case '3': temp = 0xF2; break;
  57   3            case '4': temp = 0x66; break;
  58   3            case '5': temp = 0xB6; break;
  59   3            case '6': temp = 0xBE; break;
  60   3            case '7': temp = 0xE0; break;
  61   3            case '8': temp = 0xFF; break;
  62   3            case '9': temp = 0xF6; break;
  63   3            default:  temp = 0xFC; break;
  64   3          }
  65   2          seg_buf[i] = temp;
  66   2        }
  67   1        
  68   1      }
  69          
  70          /*
  71          ======================================================================================
  72          多个数码管和LED控制函数,适用于引脚顺序不连贯,多个数码管同时控制
  73          *seg_buf:数码管段选 例seg_buf[2] = {0xFC,0x60};0xFC数码管表示为0，0x60为1
  74          seg_buf1:磁化强度数码管显示选择，=0时磁化强度显示0，=1时磁化强度显示1.选择范围只有0-3
  75          seg_buf2:按键下方的LED显示开关，按位判断，可精确控制每一位LED ，并方便移植
  76          表格：
  77          seg_led = 2b: 0 0 1  1  1  1  1  1     =1开 =0关
  78                            磁  磁 童 开 冷 磁
  79                            化  化 锁 水 水 化
  80                            时  强
  81                            间  度
  82          ======================================================================================
  83          */
  84          
  85          //void Seg_Disp(unsigned char *seg_buf1,unsigned char *seg_buf2,unsigned char seg_led, unsigned char pos)
  86          //{
  87          //  unsigned char seg_string;
  88          //  
  89          //  switch(pos){  
  90          //    case 0:{    
  91          //      DIG1 = 0;
  92          //      DIG2 = DIG3 = COM1 = COM2 = 1;    
  93          //      seg_string = seg_buf[pos];  
  94          //      break;
  95          //    }
  96          //    case 1:{
  97          //      DIG2 = 0;
  98          //      DIG1 = DIG3 = COM1 = COM2 = 1;
  99          //      seg_string = seg_buf[pos];  
 100          //      break;
 101          //    }
 102          //    case 2:{
 103          //      DIG3 = 0;
 104          //      DIG1 = DIG2 = COM1 = COM2 = 1;
 105          //      switch(seg_buf1){
 106          //        case 0:
 107          //          seg_string = 0xFC; //0
 108          //          break;
 109          //        case 1:
 110          //          seg_string = 0x60; //1
 111          //          break;
 112          //        case 2:
 113          //          seg_string = 0xDA; //2
 114          //          break;
 115          //        case 3:
 116          //          seg_string = 0xF2; //3
C51 COMPILER V9.57.0.0   SEG                                                               09/28/2024 23:49:16 PAGE 3   

 117          //          break;
 118          //        default: break;
 119          //      }
 120          //      break;
 121          //    }
 122          //    case 3:{
 123          //      COM1 = 0;
 124          //      DIG1 = DIG2 = DIG3 = COM2 = 1;
 125          //      
 126          //      if(((seg_buf2 >> 5) & 0x01))
 127          //        seg_string = 0xE0; //磁化时间LED
 128          //      else 
 129          //        seg_string = 0x00; //磁化时间LED
 130          //      
 131          //      if(((seg_buf2 >> 3) & 0x01))
 132          //        seg_string |= 0x18; //童锁LED
 133          //      else 
 134          //        seg_string &= ~0x18; //童锁LED
 135          //      
 136          //      if(((seg_buf2 >> 2) & 0x01))
 137          //        seg_string |= 0x06; //开水键LED
 138          //      else 
 139          //        seg_string &= ~0x06; //开水键LED
 140          //        
 141          //      break;
 142          //    }
 143          //    case 4:{
 144          //      COM2 = 0;
 145          //      DIG1 = DIG2 = DIG3 = COM1 = 1;
 146          //      
 147          //      if(((seg_buf2 >> 4) & 0x01))
 148          //        seg_string = 0xE0; //磁化强度LED
 149          //      else 
 150          //        seg_string = 0x00; //磁化强度LED
 151          //      
 152          //      if(((seg_buf2 >> 1) & 0x01))
 153          //        seg_string |= 0x18; //冷水LED
 154          //      else 
 155          //        seg_string &= ~0x18; //冷水LED
 156          //      
 157          //      if(seg_buf2 & 0x01)
 158          //        seg_string |= 0x06; //磁化LED
 159          //      else 
 160          //        seg_string &= ~0x06; //磁化LED
 161          //      
 162          //      break;
 163          //    }
 164          //    default: break;
 165          //  }
 166          //  
 167          //  
 168          //  LED1A = seg_string >> 7;
 169          //  LED1B = seg_string >> 6 & 0x01;
 170          //  LED1C = seg_string >> 5 & 0x01;
 171          //  LED1D = seg_string >> 4 & 0x01;
 172          //  LED1E = seg_string >> 3 & 0x01;
 173          //  LED1F = seg_string >> 2 & 0x01;
 174          //  LED1G = seg_string >> 1 & 0x01;
 175          //  
 176          //}
 177          
 178          void Seg_Disp1(unsigned char *seg_buf, unsigned char pos)
C51 COMPILER V9.57.0.0   SEG                                                               09/28/2024 23:49:16 PAGE 4   

 179          {
 180   1        unsigned char seg_string;
 181   1        
 182   1        switch(pos){  
 183   2          case 0:{    
 184   3            ADIG1 = 0;
 185   3            ADIG2 = ADIG3 = ADIG4 = 1;    
 186   3            seg_string = seg_buf[pos];  
 187   3            break;
 188   3          }
 189   2          case 1:{
 190   3            ADIG2 = 0;
 191   3            ADIG1 = ADIG3 = ADIG4 = 1;
 192   3            seg_string = seg_buf[pos];  
 193   3            break;
 194   3          }
 195   2          case 2:{
 196   3            ADIG3 = 0;
 197   3            ADIG1 = ADIG2 = ADIG4 = 1;
 198   3            seg_string = seg_buf[pos];
 199   3            break;
 200   3          }
 201   2          case 3:{
 202   3            ADIG4 = 0;
 203   3            ADIG1 = ADIG2 = ADIG3 = 1;
 204   3            seg_string = seg_buf[pos];  
 205   3            break;
 206   3          }
 207   2          default: break;
 208   2        }
 209   1      
 210   1        LED1A = seg_string >> 7;
 211   1        LED1B = seg_string >> 6 & 0x01;
 212   1        LED1C = seg_string >> 5 & 0x01;
 213   1        LED1D = seg_string >> 4 & 0x01;
 214   1        LED1E = seg_string >> 3 & 0x01;
 215   1        LED1F = seg_string >> 2 & 0x01;
 216   1        LED1G = seg_string >> 1 & 0x01;
 217   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    312    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
